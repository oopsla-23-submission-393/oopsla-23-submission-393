import "01-propositional.mm1";
import "11-definedness-normalization.mm1";

theorem negative_in_not {X: SVar} (phi: Pattern X)
  (h: $ _Positive X phi $): $ _Negative X (~ phi) $ =
  '(negative_in_imp h negative_disjoint);
theorem positive_in_or {X: SVar} (phi1 phi2: Pattern X)
  (h1: $ _Positive X phi1 $)
  (h2: $ _Positive X phi2 $):
  $ _Positive X (phi1 \/ phi2) $ =
  '(positive_in_imp (negative_in_not h1) h2);

theorem eFresh_ceil {x: EVar} (phi: Pattern x)
  (h: $ _eFresh x phi $):
  $ _eFresh x (|^ phi ^|) $ =
  '(eFresh_app eFresh_disjoint h);
theorem eFresh_mem {x y: EVar} (phi: Pattern x y)
  (h: $ _eFresh x phi $):
  $ _eFresh x (y in phi) $ =
  '(eFresh_ceil @ eFresh_and_r h);
theorem eFresh_ctximp_same_var {box: SVar} (ctx phi: Pattern box):
  $ _eFresh x (ctximp_app box ctx phi) $ =
  '(eFresh_exists_same_var);

theorem sFresh_ceil {X: SVar} (phi: Pattern X)
  (h: $ _sFresh X phi $):
  $ _sFresh X (|^ phi ^|) $ =
  '(sFresh_app sFresh_disjoint h);
theorem sFresh_mem {X: SVar} {y: EVar} (phi: Pattern X y)
  (h: $ _sFresh X phi $):
  $ _sFresh X (y in phi) $ =
  '(sFresh_ceil @ sFresh_and_r h);

theorem _eSubst_ceil {x: EVar} (phi psi rho: Pattern x)
  (h: $ Norm (e[ phi / x ] psi) rho $):
  $ Norm (e[ phi / x ] (|^ psi ^|)) (|^ rho ^|) $ =
  '(_eSubst_app eSubstitution_disjoint h);
theorem _eSubst_floor {x: EVar} (phi psi rho: Pattern x)
  (h: $ Norm (e[ phi / x ] psi) rho $):
  $ Norm (e[ phi / x ] (|_ psi _|)) (|_ rho _|) $ =
  '(_eSubst_not @ _eSubst_ceil @ _eSubst_not h);
theorem _eSubst_mem_same_var {x: EVar} (phi phi2 psi2: Pattern x)
  (h: $ Norm (e[ phi / x ] phi2) psi2 $):
  $ Norm (e[ phi / x ] (x in phi2)) (|^ phi /\ psi2 ^|) $ =
  '(_eSubst_ceil @ _eSubst_and (eSubstitution_in_same_eVar) h);
theorem _eSubst_subset {x: EVar} (phi phi1 phi2 psi1 psi2: Pattern x)
  (h1: $ Norm (e[ phi / x ] phi1) psi1 $)
  (h2: $ Norm (e[ phi / x ] phi2) psi2 $):
  $ Norm (e[ phi / x ] (phi1 C_ phi2)) (psi1 C_ psi2) $ =
  '(_eSubst_floor @ _eSubst_imp h1 h2);
theorem _eSubst_eq {x: EVar} (phi phi1 phi2 psi1 psi2: Pattern x)
  (h1: $ Norm (e[ phi / x ] phi1) psi1 $)
  (h2: $ Norm (e[ phi / x ] phi2) psi2 $):
  $ Norm (e[ phi / x ] (phi1 == phi2)) (psi1 == psi2) $ =
  '(_eSubst_floor @ _eSubst_equiv h1 h2);

theorem KT_subst {X: SVar} (phi psi rho: Pattern X)
  (h_pos: $ _Positive X phi $)
  (h_subst: $ Norm (s[ psi / X ] phi) rho $)
  (h: $ rho -> psi $):
  $ (mu X phi) -> psi $ =
  '(KT h_pos @ norm (norm_sym @ norm_imp_l h_subst) h);

--- prop_44
theorem imp_cong_of_equiv_not: $(phi1 <-> phi2) -> (~phi1 <-> ~phi2)$ = 'noteq;
theorem imp_cong_of_equiv_imp_l: $(phi1 <-> phi2) -> ((phi1 -> psi) <-> (phi2 -> psi))$ = '(rsyl ancom @ anim imim1 imim1);
theorem imp_cong_of_equiv_imp_r: $(phi1 <-> phi2) -> ((psi -> phi1) <-> (psi -> phi2))$ = '(anim imim2 imim2);
theorem imp_cong_of_equiv_imp: $(phi1 <-> phi2) -> (psi1 <-> psi2) -> ((phi1 -> psi1) <-> (phi2 -> psi2))$ = '(syl5 imp_cong_of_equiv_imp_r @ syl bitr imp_cong_of_equiv_imp_l);
theorem imp_cong_of_equiv_or_l: $(phi1 <-> phi2) -> ((phi1 \/ psi) <-> (phi2 \/ psi))$ = 'oreq1d;
theorem imp_cong_of_equiv_or_r: $(phi1 <-> phi2) -> ((psi \/ phi1) <-> (psi \/ phi2))$ = 'oreq2d;
theorem imp_cong_of_equiv_or: $(phi1 <-> phi2) -> (psi1 <-> psi2) -> ((phi1 \/ psi1) <-> (phi2 \/ psi2))$ = 'oreq;
theorem imp_cong_of_equiv_and: $(phi1 <-> phi2) -> (psi1 <-> psi2) -> ((phi1 /\ psi1) <-> (phi2 /\ psi2))$ = 'aneq;
theorem imp_cong_of_equiv_and_l: $(phi1 <-> phi2) -> ((phi1 /\ psi) <-> (phi2 /\ psi))$ = '(com12 aneq biid);
theorem imp_cong_of_equiv_and_r: $(phi1 <-> phi2) -> ((psi /\ phi1) <-> (psi /\ phi2))$ = '(aneq biid);
theorem imp_cong_of_equiv_equiv: $(phi1 <-> phi2) -> (psi1 <-> psi2) -> ((phi1 <-> psi1) <-> (phi2 <-> psi2))$ = 'bieq;
theorem imp_cong_of_equiv_equiv_l: $(phi1 <-> phi2) -> ((phi1 <-> psi) <-> (phi2 <-> psi))$ = 'bieq1;
theorem imp_cong_of_equiv_equiv_r: $(phi1 <-> phi2) -> ((psi <-> phi1) <-> (psi <-> phi2))$ = 'bieq2;

-- The following exist for optimization reasons
theorem cong_of_equiv_not (h: $phi1 <-> phi2$): $~phi1 <-> ~phi2$ = '(imp_cong_of_equiv_not h);
theorem cong_of_equiv_imp_l (h: $phi1 <-> phi2$): $(phi1 -> psi) <-> (phi2 -> psi)$ = '(imp_cong_of_equiv_imp_l h);
theorem cong_of_equiv_imp_r (h: $phi1 <-> phi2$): $(psi -> phi1) <-> (psi -> phi2)$ = '(imp_cong_of_equiv_imp_r h);
theorem cong_of_equiv_imp (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$): $(phi1 -> psi1) <-> (phi2 -> psi2)$ = '(imp_cong_of_equiv_imp h1 h2);
theorem cong_of_equiv_or_l (h: $phi1 <-> phi2$): $(phi1 \/ psi) <-> (phi2 \/ psi)$ = '(imp_cong_of_equiv_or_l h);
theorem cong_of_equiv_or_r (h: $phi1 <-> phi2$): $(psi \/ phi1) <-> (psi \/ phi2)$ = '(imp_cong_of_equiv_or_r h);
theorem cong_of_equiv_or (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$): $(phi1 \/ psi1) <-> (phi2 \/ psi2)$ = '(imp_cong_of_equiv_or h1 h2);
theorem cong_of_equiv_and_l (h: $phi1 <-> phi2$): $(phi1 /\ psi) <-> (phi2 /\ psi)$ = '(imp_cong_of_equiv_and_l h);
theorem cong_of_equiv_and_r (h: $phi1 <-> phi2$): $(psi /\ phi1) <-> (psi /\ phi2)$ = '(imp_cong_of_equiv_and_r h);
theorem cong_of_equiv_and (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$): $(phi1 /\ psi1) <-> (phi2 /\ psi2)$ = '(imp_cong_of_equiv_and h1 h2);
theorem cong_of_equiv_equiv (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$): $(phi1 <-> psi1) <-> (phi2 <-> psi2)$ = '(imp_cong_of_equiv_equiv h1 h2);
theorem cong_of_equiv_equiv_l (h: $phi1 <-> phi2$): $(phi1 <-> psi) <-> (phi2 <-> psi)$ = '(imp_cong_of_equiv_equiv_l h);
theorem cong_of_equiv_equiv_r (h: $phi1 <-> phi2$): $(psi <-> phi1) <-> (psi <-> phi2)$ = '(imp_cong_of_equiv_equiv_r h);
theorem cong_of_equiv_nnimp (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$): $(~phi1 \/ psi1) <-> (~phi2 \/ psi2)$ =
  '(cong_of_equiv_or (cong_of_equiv_not h1) h2);

--- Appendix C: Properties of Proof System H
--------------------------------------------

theorem propag_exists_def {x: EVar} (phi: Pattern x):
  $ |^ exists x phi ^| -> exists x (|^ phi ^|) $ =
  '(norm (norm_imp defNorm @ norm_exists defNorm) (! propag_exists_disjoint box));

theorem prop_43_bot (rho: Pattern): $ bot -> rho $ = 'absurdum;
theorem prop_43_or {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ (app[ phi1 / box ] ctx \/ app[ phi2 / box ] ctx) -> app[ phi1 \/ phi2 / box ] ctx $ =
  '(eori (framing orl) (framing orr));
theorem prop_43_exists {box: SVar} {x: EVar} (ctx: Pattern box) (phi: Pattern box x):
  $ (exists x (app[ phi / box ] ctx)) -> app[ exists x phi / box ] ctx $ =
  '(exists_generalization (eFresh_appCtx eFresh_disjoint eFresh_exists_same_var) (framing exists_intro_same_var));

theorem exists_appCtx {x: EVar} {box: SVar} (ctx: Pattern box) (phi: Pattern x):
  $ (app[ exists x phi / box ] ctx) <-> exists x (app[ phi / box ] ctx) $ =
  '(ibii propag_exists_disjoint prop_43_exists);
theorem or_appCtx {box: SVar} (ctx: Pattern box) (phi psi: Pattern):
  $ (app[ phi \/ psi / box ] ctx) <-> (app[ phi / box ] ctx) \/ (app[ psi / box ] ctx) $ =
  '(ibii propag_or prop_43_or);
theorem or_appCtx2 {box: SVar} (ctx: Pattern box) (phi psi: Pattern):
  $ (app[ phi \/ psi \/ rho / box ] ctx) <-> (app[ phi / box ] ctx) \/ (app[ psi / box ] ctx) \/ (app[ rho / box ] ctx) $ =
  '(bitr or_appCtx @ cong_of_equiv_or_l or_appCtx);
theorem or_appCtx2_r {box: SVar} (ctx: Pattern box) (phi psi: Pattern):
  $ (app[ phi \/ (psi \/ rho) / box ] ctx) <-> (app[ phi / box ] ctx) \/ ((app[ psi / box ] ctx) \/ (app[ rho / box ] ctx)) $ =
  '(bitr or_appCtx @ cong_of_equiv_or_r or_appCtx);

theorem prop_43_or_def (phi1 phi2: Pattern):
  $ (|^ phi1 ^| \/ |^ phi2 ^|) -> |^ phi1 \/ phi2 ^| $ =
  '(eori (framing_def orl) (framing_def orr));
theorem prop_43_exists_def {x: EVar} (phi: Pattern x):
  $ (exists x (|^ phi ^|)) -> |^ exists x phi ^| $ =
  '(exists_generalization (eFresh_app eFresh_disjoint eFresh_exists_same_var) (framing_def exists_intro_same_var));

do {
  (def (ex_appCtx_subst subst) '(norm (norm_equiv ,subst @ norm_exists ,subst) exists_appCtx))
  (def (or_appCtx_subst subst) '(norm (norm_equiv ,subst @ norm_or ,subst ,subst) or_appCtx))
  (def (or_appCtx2_subst subst) '(norm (norm_equiv ,subst @ norm_or (norm_or ,subst ,subst) ,subst) or_appCtx2))
  (def (or_appCtx2_r_subst subst) '(norm (norm_equiv ,subst @ norm_or ,subst (norm_or ,subst ,subst)) or_appCtx2_r))
  (def (framing_subst hyp subst) '(norm (norm_imp ,subst ,subst) @ framing ,hyp))
};

theorem exists_intro_l_bi_disjoint {x: EVar} (phi: Pattern x) (psi: Pattern)
  (h: $ phi <-> psi $):
  $ (exists x phi) <-> psi $ =
  '(ibii
    (exists_generalization_disjoint @ anl h)
    (syl exists_intro_same_var @ anr h));

theorem propag_and_floor: $|_ phi /\ psi _| <-> |_ phi _| /\ |_ psi _|$ =
  '(ibii
    (iand (framing_floor anl) (framing_floor anr))
    (rsyl (anr notor) @ rsyl (con3 propag_or_def) @ con3 @ framing_def @ anl notan)
  );

theorem appCtxLR {box: SVar} (phi2 phi3: Pattern) (phi1 phi4: Pattern box):
  $ Norm (app[ phi1 / box ] (app (app phi3 phi4) phi2)) (app (app phi3 (app[ phi1 / box ] phi4)) phi2) $ =
  '(norm_trans appCtxL_disjoint @ norm_app_l appCtxR_disjoint);
theorem appCtxLVar {box: SVar} (phi1 phi2: Pattern):
  $ Norm (app[ phi1 / box ] (app (sVar box) phi2)) (app phi1 phi2) $ =
  '(norm_trans appCtxL_disjoint @ norm_app appCtxVar norm_refl);
theorem appCtxRVar {box: SVar} (phi1 phi2: Pattern):
  $ Norm (app[ phi2 / box ] (app phi1 (sVar box))) (app phi1 phi2) $ =
  '(norm_trans appCtxR_disjoint @ norm_app norm_refl appCtxVar);
theorem appCtxLRVar {box: SVar} (phi1 phi2 phi3: Pattern):
  $ Norm (app[ phi1 / box ] (app (app phi3 (sVar box)) phi2)) (app (app phi3 phi1) phi2) $ =
  '(norm_trans appCtxL_disjoint @ norm_app appCtxRVar norm_refl);

theorem app_framing_l (h: $phi1 -> phi2$): $(app phi1 psi) -> (app phi2 psi)$ =
  '(norm (norm_imp appCtxLVar appCtxLVar) (! framing box _ _ _ h));
theorem app_framing_r (h: $phi1 -> phi2$): $(app psi phi1) -> (app psi phi2)$ =
  '(norm (norm_imp appCtxRVar appCtxRVar) (! framing box _ _ _ h));

theorem sSubst_ctx_framing{X: SVar} (phi phi1 phi2: Pattern X)
  (h: $ phi1 -> phi2 $): $ (s[ phi / X ] phi1) -> (s[ phi / X ] phi2) $ =
  '(norm sSubstitution_in_imp @ set_var_subst h);
theorem mu_framing {X: SVar} (phi1 phi2: Pattern X)
  (pos1: $ _Positive X phi1 $)
  (pos2: $ _Positive X phi2 $)
  (h: $ phi1 -> phi2 $):
  $ mu X phi1 -> mu X phi2 $ =
  '(KT pos1 @ rsyl (sSubst_ctx_framing h) (pre_fixpoint pos2));
theorem mu_framing_disjoint {X: SVar} (phi1 phi2: Pattern)
  (h: $ phi1 -> phi2 $):
  $ mu X phi1 -> mu X phi2 $ =
  '(mu_framing positive_disjoint positive_disjoint h);

theorem cong_of_equiv_app_l (h: $phi1 <-> phi2$): $(app phi1 psi) <-> (app phi2 psi)$ = '(ibii
  (app_framing_l @ anl h)
  (app_framing_l @ anr h));
theorem cong_of_equiv_app_r (h: $phi1 <-> phi2$): $(app psi phi1) <-> (app psi phi2)$ = '(ibii
  (app_framing_r @ anl h)
  (app_framing_r @ anr h));
theorem cong_of_equiv_app (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$): $(app phi1 psi1) <-> (app phi2 psi2)$ =
  '(bitr (cong_of_equiv_app_l h1) (cong_of_equiv_app_r h2));
theorem cong_of_equiv_exists {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 <-> phi2 $): $ (exists x phi1) <-> (exists x phi2) $ =
  '(iani (exists_framing @ anl h) (exists_framing @ anr h));
theorem cong_of_equiv_sSubst_ctx {X: SVar} (phi phi1 phi2: Pattern X)
  (h: $ phi1 <-> phi2 $): $ (s[ phi / X ] phi1) <-> (s[ phi / X ] phi2) $ = '(ibii
    (sSubst_ctx_framing @ anl h)
    (sSubst_ctx_framing @ anr h));
theorem cong_of_equiv_mu {X: SVar} (phi1 phi2: Pattern X)
  (pos1: $ _Positive X phi1 $)
  (pos2: $ _Positive X phi2 $)
  (h: $ phi1 <-> phi2 $): $ (mu X phi1) <-> (mu X phi2) $ = '(ibii
    (mu_framing pos1 pos2 @ anl h)
    (mu_framing pos2 pos1 @ anr h));
theorem cong_of_equiv_appCtx {box: SVar} (phi: Pattern box)
  (h: $ phi1 <-> phi2 $):
  $ (app[ phi1 / box ] phi) <-> app[ phi2 / box ] phi $ = '(ibii
    (framing @ anl h)
    (framing @ anr h));
theorem cong_of_equiv_def (h: $ phi1 <-> phi2 $):
  $ |^ phi1 ^| <-> |^ phi2 ^| $ = '(ibii
    (framing_def @ anl h)
    (framing_def @ anr h));
theorem cong_of_equiv_floor (h: $ phi1 <-> phi2 $):
  $ |_ phi1 _| <-> |_ phi2 _| $ =
  '(cong_of_equiv_not @ cong_of_equiv_def @ cong_of_equiv_not h);
theorem cong_of_equiv_subset (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$):
  $ (phi1 C_ psi1) <-> (phi2 C_ psi2) $ =
  '(cong_of_equiv_floor @ cong_of_equiv_imp h1 h2);
theorem cong_of_equiv_mem {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 <-> phi2 $):
  $ (x in phi1) <-> (x in phi2) $ = '(cong_of_equiv_def @ cong_of_equiv_and_r h);
theorem cong_of_equiv_eq (h1: $phi1 <-> phi2$) (h2: $psi1 <-> psi2$): $(phi1 == psi1) <-> (phi2 == psi2)$ =
  '(cong_of_equiv_not @ cong_of_equiv_def @ cong_of_equiv_not @ cong_of_equiv_equiv h1 h2);

do {
  (def (cong_eq_lift pf to_eq) '(equiv_to_eq @ ,pf (corollary_57_floor ,to_eq)))
  (def (cong_eq_lift2 pf to_eq1 to_eq2) '(equiv_to_eq @ ,pf (corollary_57_floor ,to_eq1) (corollary_57_floor ,to_eq2)))
};

theorem univ_gene {x: EVar} (phi: Pattern x)
  (p: $ phi $):
  $ forall x phi $ = '(exists_generalization_disjoint @ notnot1 p);
theorem var_subst {x y: EVar} (phi: Pattern x y):
  $ (forall x phi) -> e[ eVar y / x ] phi $ =
  '(con1 @ norm (norm_imp eSubstitution_in_not norm_refl) exists_intro);
theorem var_subst_same_var {x: EVar} (phi: Pattern x):
  $ (forall x phi) -> phi $ = '(con1 exists_intro_same_var);

theorem lemma_46 (phi: Pattern) {box: SVar} (ctx: Pattern box)
  (p : $ phi $):
  $ ~ (app[ (~ phi) / box ] ctx) $ = '(syl propag_bot @ framing @ notnot1 p);


theorem lemma_46_floor
  (h: $phi$)
: $|_ phi _|$
= '(norm (norm_not @ ! defNorm box) @ lemma_46 h);
theorem imp_to_subset  (h: $ phi -> psi $): $ phi C_ psi $ = '(lemma_46_floor h);
theorem equiv_to_eq  (h: $ phi <-> psi $): $ phi == psi $ = '(lemma_46_floor h);
theorem eq_imp_subset: $ (phi == psi) -> (phi C_ psi) $ = '(framing_floor anl);
theorem subset_to_eq: $ (phi C_ psi) -> (psi C_ phi) -> (phi == psi) $ = '(exp @ anr propag_and_floor);

theorem eq_refl: $ phi == phi $ = '(equiv_to_eq biid);
theorem functional_same_var: $ exists x (eVar x == eVar x) $ = '(exists_intro_same_var eq_refl);
theorem functional_var: $ exists x (eVar x == eVar y) $ =
  '(exists_intro @ norm (norm_sym @ _eSubst_eq eSubstitution_in_same_eVar eSubstitution_disjoint) eq_refl);

theorem eq_sym: $ (phi1 == phi2) -> (phi2 == phi1) $ =
  '(con3 @ framing_def @ con3 bicom);

theorem subset_imp_subset_or_l:
  $(phi C_ psi) -> (phi C_ (psi \/ rho))$ =
  '(framing_floor @ imim2i orl);
theorem subset_imp_subset_or_r:
  $(phi C_ psi) -> (phi C_ (rho \/ psi))$ =
  '(framing_floor @ imim2i orr);

theorem subset_and: $ (phi C_ (psi1 /\ psi2)) -> (phi C_ psi1) /\ (phi C_ psi2) $ =
  '(iand (framing_subset id anl) (framing_subset id anr));

theorem taut_equiv_top (h: $ phi $): $ phi <-> top $ =
  '(ibii imp_top @ a1i h);
theorem taut_and_equiv (h: $ phi $): $ phi /\ psi <-> psi $ =
  '(bitr (cong_of_equiv_and_l @ taut_equiv_top h) an_top_bi_r);
theorem taut_is_top (h: $ phi $): $ phi == top $ =
  '(equiv_to_eq @ taut_equiv_top h);
theorem absurd_and_equiv_bot (h: $ ~ phi $): $ phi /\ psi <-> bot $ =
  '(ibii (syl h anl) absurdum);

theorem membership_intro_implicit {x: EVar} (phi: Pattern x)
  (h: $ phi $):
  $ x in phi $ =
  '(framing_def (iand id (a1i h)) definedness);

theorem membership_intro {x: EVar} (phi: Pattern x)
  (h: $ phi $):
  $ forall x (x in phi) $ =
  '(univ_gene @ membership_intro_implicit h);

theorem membership_elim {x: EVar} (phi: Pattern)
  (h: $ forall x (x in phi) $):
  $ phi $ =
  '(dne @ exists_generalization_disjoint (dne @ dne (norm (norm_not @ norm_and (! defNorm box1) (! appCtxVar box2)) singleton) @ var_subst_same_var h) existence);

theorem membership_elim_implicit {x: EVar} (phi: Pattern)
  (h: $ x in phi $):
  $ phi $ =
  '(membership_elim @ univ_gene h);

theorem membership_var_forward {x y: EVar}: $ (x in (eVar y)) -> (eVar x == eVar y) $
 = '( rsyl (iand (dne singletonDef) (imim1i (framing_def ancom) @ dne @ norm (norm_not @ norm_and defNorm defNorm) (! singleton box1 box2)))
    @ rsyl (anri not_distr_or)
    @ rsyl (con3 @ norm (norm_imp norm_refl @ norm_or defNorm defNorm) propag_or)
    @ con3
    @ norm (norm_imp defNorm norm_refl)
      (! framing box _ _ _ @ anr lemma_51));
theorem membership_var_reverse {x y: EVar}: $ (eVar x == eVar y) -> (x in (eVar y)) $
 = '(propag_or_def @ framing_def or_imp_xor_and @ norm defNorm @ prop_43_or @ norm (norm_sym @ norm_or defNorm (! defNorm box)) @ orl definedness);
theorem membership_var_bi {x y: EVar}:
  $ (x in (eVar y)) <-> (eVar x == eVar y) $
 = '(iani membership_var_forward  membership_var_reverse);
theorem membership_var {x y: EVar}:
  $ (x in (eVar y)) == (eVar x == eVar y) $
 = '(equiv_to_eq membership_var_bi);

theorem membership_same_var: $ x in eVar x $ = '(framing_def (iand id id) definedness);

theorem membership_not_forward {x: EVar} (phi: Pattern x):
  $(x in ~phi) -> ~(x in phi) $ = '(con2 @ dne singletonDef);
theorem membership_not_reverse {x: EVar} (phi: Pattern x):
  $~(x in phi) -> (x in ~phi) $ =
  '(propag_or_def @ framing_def (exp @ iand anl @ curry @ com12 dne) definedness);
theorem membership_not_bi {x: EVar} (phi: Pattern x):
  $ (x in ~phi) <-> ~(x in phi) $ =
  '(iani membership_not_forward membership_not_reverse);
theorem membership_not {x: EVar} (phi: Pattern x):
  $ (x in ~phi) == ~(x in phi) $ =
  '(equiv_to_eq membership_not_bi);

theorem framing_in {x: EVar} (phi1 phi2: Pattern x)
  (h: $ phi1 -> phi2 $):
  $ (x in phi1) -> (x in phi2)$ =
  '(framing_def @ anim2 h);


--- (membership and)
theorem membership_and_forward {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) -> (x in phi1) /\ (x in phi2) $
  = '(iand (framing_def @ iand anl anrl) (framing_def @ iand anl anrr));
theorem membership_and_reverse {x: EVar} (phi1 phi2: Pattern x):
  $  (x in phi1) /\ (x in phi2) -> x in (phi1 /\ phi2) $
  ='(syl dne @ con2 @ rsyl membership_not_reverse @ rsyl (framing_in @ anl notan) @ rsyl
      (framing_def @ anl andi)
      (rsyl (norm (norm_imp defNorm @ norm_or defNorm defNorm) (! propag_or box)) @ rsyl (orim (con2 @ dne singletonDef) (con2 @ dne singletonDef)) (anr notan)));
theorem membership_and_bi {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) <-> (x in phi1) /\ (x in phi2) $
  = '(iani membership_and_forward membership_and_reverse);
theorem membership_and {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 /\ phi2) == (x in phi1) /\ (x in phi2) $ =
  '(equiv_to_eq membership_and_bi);

theorem membership_imp_forward {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 -> phi2) -> (x in phi1) -> (x in phi2) $ =
  '(exp @ rsyl membership_and_reverse @ framing_in @ impcom @ syl mpcom id );
theorem membership_imp_reverse {x: EVar} (phi1 phi2: Pattern x):
  $((x in phi1) -> (x in phi2))  -> x in (phi1 -> phi2)$ =
  '(imp_to_or @ eori (rsyl membership_not_reverse @ framing_in absurd)
                     (framing_in @ com12 idd ) );
theorem membership_imp_bi {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 -> phi2) <-> (x in phi1) -> (x in phi2) $ =
  '(iani membership_imp_forward membership_imp_reverse);
theorem membership_imp {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 -> phi2) == (x in phi1) -> (x in phi2) $ =
  '(equiv_to_eq membership_imp_bi);

theorem membership_or_bi {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 \/ phi2) <-> (x in phi1) \/ (x in phi2) $
  = '(bitr membership_imp_bi @ cong_of_equiv_imp_l membership_not_bi);
theorem membership_or {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 \/ phi2) == (x in phi1) \/ (x in phi2) $
  = '(equiv_to_eq membership_or_bi);

theorem membership_exists_forward {x y: EVar} (phi: Pattern x y):
  $ (x in (exists y phi)) -> exists y (x in phi) $
  = '(rsyl (framing_def and_exists_disjoint_reverse) propag_exists_def);
theorem membership_exists_reverse {x y: EVar} (phi: Pattern x y):
  $ (exists y (x in phi) -> x in (exists y phi)) $
  = '(rsyl prop_43_exists_def @ framing_def and_exists_disjoint_forwards);
theorem membership_exists_bi {x y: EVar} (phi: Pattern x y):
  $ (x in (exists y phi)) <-> exists y (x in phi) $
  = '(iani membership_exists_forward membership_exists_reverse);
theorem membership_exists {x y: EVar} (phi: Pattern x y):
  $ (x in (exists y phi)) == exists y (x in phi) $
  = '(equiv_to_eq membership_exists_bi);

theorem membership_equiv_bi {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 <-> phi2) <-> ((x in phi1) <-> (x in phi2)) $
  = '(bitr membership_and_bi @ cong_of_equiv_and membership_imp_bi membership_imp_bi);
theorem membership_equiv {x: EVar} (phi1 phi2: Pattern x):
  $ x in (phi1 <-> phi2) == ((x in phi1) <-> (x in phi2)) $
  = '(equiv_to_eq membership_equiv_bi);


theorem eVar_in_subset {x: EVar} (phi: Pattern x):
  $ (x in phi) <-> (eVar x C_ phi) $ =
  '(con2b @ bitr (cong_of_equiv_def @ cong_of_equiv_not @ cong_of_equiv_imp_r notnot) membership_not_bi);
theorem eVar_in_subset_rev {x: EVar} (phi: Pattern x):
  $ (eVar x C_ phi) <-> (x in phi) $ =
  '(bicom eVar_in_subset);
theorem eVar_in_subset_forward {x: EVar} (phi: Pattern x):
  $ (x in phi) -> (eVar x C_ phi) $
= '(bi1i eVar_in_subset);
theorem eVar_in_subset_reverse {x: EVar} (phi: Pattern x):
  $ (eVar x C_ phi) -> (x in phi) $
= '(bi2i eVar_in_subset);

theorem eVars_subset_eq_forward {x y: EVar}:
  $ (eVar x C_ eVar y) -> (eVar x == eVar y) $ =
  '(rsyl eVar_in_subset_reverse membership_var_forward);
theorem eVars_subset_eq_reverse {x y: EVar}:
  $ (eVar x == eVar y) -> (eVar x C_ eVar y) $ =
  'eq_imp_subset;
theorem eVars_subset_eq {x y: EVar}:
  $ (eVar x C_ eVar y) <-> (eVar x == eVar y) $ =
  '(ibii eVars_subset_eq_forward eVars_subset_eq_reverse);

theorem lemma_exists_and: $ phi <-> exists x (eVar x /\ phi) $ =
  '(ibii
    (rsyl notnot1 @ anr or_exists_disjoint @ exists_framing
      (expcom @ iand appl @ rsyl anl dne)
      @ anl or_exists_disjoint @ orr existence)
    (exists_generalization_disjoint anr));

theorem lemma_ceil_exists_membership:
  $ |^ phi ^| <-> exists x (x in phi) $ =
  '(bitr (cong_of_equiv_def lemma_exists_and) @
    ibii propag_exists_def prop_43_exists_def);

theorem lemma_56 {box: SVar} (phi ctx: Pattern box)
: $ (app[ phi / box ] ctx) -> |^ phi ^| $ =
  '(rsyl (rsyl (framing @ anl lemma_exists_and) @ propag_exists eFresh_disjoint)
    (exists_generalization eFresh_disjoint @ rsyl
      (dne @ singleton_norm norm_refl (! defNorm box2))
      (propag_or_def @ framing_def (anl com12b @ rsyl dne @ imim2i dne) (! definedness x))
    ));

theorem corollary_57_ceil (phi: Pattern): $ phi -> |^ phi ^| $ =
  '(norm (norm_imp_l appCtxVar) (! lemma_56 box));
theorem corollary_57_floor (phi: Pattern): $ |_ phi _| -> phi $ =
  '(con1 corollary_57_ceil);

theorem not_ceil_floor_bi: $ ~ |^ phi ^| <-> |_ ~ phi _| $ = '(con3b @ cong_of_equiv_def notnot);
theorem def_idem: $ |^ (|^ phi ^|) ^| <-> |^ phi ^| $ =
  '(ibii (norm (norm_imp_l defNorm2) (! lemma_56 box _ _)) @ framing_def corollary_57_ceil);
theorem floor_idem: $ |_ (|_ phi _|) _| <-> |_ phi _| $ =
  '(bitr (bicom not_ceil_floor_bi) @ con3b def_idem);

theorem subset_to_imp: $ (phi C_ psi) -> (phi -> psi) $ = 'corollary_57_floor;

--- lemma 60
theorem lemma_60_forward {x: EVar} {box: SVar} (ctx phi1 phi2: Pattern box x):
  $ (app[ phi1 /\ (x in phi2) / box ] ctx) -> ((app[ phi1 / box ] ctx) /\ (x in phi2)) $ =
  '(iand (framing anl) @
    rsyl (framing anr) @ rsyl (norm (
        norm_imp (norm_trans appCtxNested_disjoint @ norm_ctxApp_pt norm_refl (! defNorm box1)) @ norm_not (! defNorm box2)
      ) @ dne singleton) @ propag_or_def @ framing_def lemma_60_helper_1 definedness);

theorem lemma_60_reverse {x: EVar} {box: SVar} (ctx phi2: Pattern box x) (phi1: Pattern x):
  $ ((app[ phi1 / box ] ctx) /\ (x in phi2)) -> app[ phi1 /\ (x in phi2) / box ] ctx $ =
  '(rsyl (anim2 @
      syl (con3 @ framing @ membership_not_reverse) @
      norm (norm_imp (! defNorm box1) @ norm_not @ norm_trans appCtxNested_disjoint @ norm_ctxApp_pt norm_refl (! defNorm box2)) @
    dne singleton) @ curry @ syl propag_or @ framing lemma_60_helper_2);

theorem lemma_60 {x: EVar} {box: SVar} (ctx: Pattern box x) (phi1 phi2: Pattern x):
  $ (app[ phi1 /\ (x in phi2) / box ] ctx) <-> ((app[ phi1 / box ] ctx) /\ (x in phi2)) $ =
  '(ibii lemma_60_forward lemma_60_reverse);
theorem lemma_60_b {x: EVar} {box: SVar} (ctx: Pattern box x) (phi1 phi2: Pattern x):
  $ (app[ (x in phi2) /\ phi1 / box ] ctx) <-> ((x in phi2) /\ (app[ phi1 / box ] ctx)) $ =
  '(bitr (cong_of_equiv_appCtx ancomb) @ bitr lemma_60 ancomb);
theorem lemma_60_subset {x: EVar} {box: SVar} (ctx: Pattern box x) (phi1 phi2: Pattern x):
  $ (app[ phi1 /\ (eVar x C_ phi2) / box ] ctx) <-> ((app[ phi1 / box ] ctx) /\ (eVar x C_ phi2)) $ =
  '(bisquare (cong_of_equiv_appCtx @ cong_of_equiv_and_r eVar_in_subset_rev) (cong_of_equiv_and_r eVar_in_subset_rev) lemma_60);

do {
  (def (lemma_60_subst subst) '(norm (norm_equiv ,subst @ norm_and_l ,subst) lemma_60))
  (def (lemma_60_subset_subst subst) '(norm (norm_equiv ,subst @ norm_and_l ,subst) lemma_60_subset))
  (def (lemma_60_b_subst subst) '(norm (norm_equiv ,subst @ norm_and_r ,subst) lemma_60_b))
};

theorem ceil_appCtx {box: SVar} (ctx: Pattern box) (phi: Pattern):
  $ (app[ |^ phi ^| / box ] ctx) -> |^ phi ^| $ =
  (named '(syl (anr lemma_ceil_exists_membership) @ rsyl (framing (anl lemma_ceil_exists_membership)) @ rsyl propag_exists_disjoint @ exists_framing @
    syl anr @ syl lemma_60_forward @ framing top_and));

--- Lemma 62
theorem lemma_62_forward {x: EVar} (phi: Pattern):
  $ (exists x ((x in phi) /\ eVar x)) -> phi $ =
  '(exists_generalization_disjoint @ syl dne @ dne @ con3 (bi1i anass) (singleton_norm (! defNorm box1) (! appCtxVar box2)));
theorem lemma_62_reverse {y: EVar} (phi: Pattern) {.box: SVar}:
  $ phi -> (exists y ((y in phi) /\ eVar y))$
  = '( ! membership_elim x _
     @ exists_generalization eFresh_disjoint
     @ notnot1
     @ membership_imp_reverse
     @ syl membership_exists_reverse
     @ syl (bi2i @ cong_of_equiv_exists membership_and_bi)
     @ syl (bi2i @ cong_of_equiv_exists @ cong_of_equiv_and_r membership_var_bi)
     @ syl (! exists_intro y x)
     @ norm (norm_imp norm_refl @ norm_sym @ norm_trans eSubstitution_in_and
                @ norm_and (norm_trans eSubstitution_in_app @ norm_app
                              eSubstitution_disjoint
                            @ norm_trans eSubstitution_in_and @ norm_and eSubstitution_disjoint
                            @ norm_trans eSubstitution_in_app @ norm_app eSubstitution_disjoint
                            @ norm_trans eSubstitution_in_and @ norm_and
                              eSubstitution_in_same_eVar
                              eSubstitution_disjoint)
                           ( norm_trans eSubstitution_in_not @ norm_not
                            @ norm_trans eSubstitution_in_app @ norm_app eSubstitution_disjoint
                            @ norm_trans eSubstitution_in_not @ norm_not
                            @ norm_trans eSubstitution_in_and @ norm_and
                              (norm_trans eSubstitution_in_imp @ norm_imp
                                 eSubstitution_disjoint eSubstitution_in_same_eVar )
                              (norm_trans eSubstitution_in_imp @ norm_imp
                                 eSubstitution_in_same_eVar eSubstitution_disjoint )   )
            )
     @ iand ( syl (norm (norm_imp (norm_and defNorm norm_refl) @ defNorm) (! lemma_60_reverse _ box) )
            @ iand (a1i definedness)
                   id
            )
            (a1i eq_refl)
     );

theorem lemma_62_b_forward:
  $ (exists x (eVar x /\ x in phi)) -> phi $ =
  '(syl lemma_62_forward @ exists_framing ancom);
theorem lemma_62_b_reverse:
  $ phi -> (exists y (eVar y /\ y in phi)) $ =
  '(rsyl lemma_62_reverse @ exists_framing ancom);
theorem lemma_62:   $ (exists x ((x in phi) /\ eVar x)) <-> phi $ = '(ibii lemma_62_forward   lemma_62_reverse);
theorem lemma_62_b: $ (exists x (eVar x /\ (x in phi))) <-> phi $ = '(ibii lemma_62_b_forward lemma_62_b_reverse);

theorem lemma_14 {box: SVar} (ctx psi phi1 phi2: Pattern box)
  (h: $ |_ psi _| -> phi1 -> phi2 $):
  $ |_ psi _| -> (app[ phi1 / box ] ctx) -> app[ phi2 / box ] ctx $ =
  '(com12 @ con1d @ rsyl
    (syl propag_or @ framing @ syl (imim2 dne) @ con3d @ com12 h)
    (imim2 @ norm (norm_imp_l @ norm_trans appCtxNested_disjoint @ norm_ctxApp_pt norm_refl defNorm) (! lemma_56 box2))
  );

theorem appCtx_pointwise {box: SVar} (ctx: Pattern box) (phi: Pattern):
  $ app[ phi / box ] ctx <-> exists x ((app[ eVar x / box ] ctx) /\ x in phi) $ =
  '(bitr (cong_of_equiv_appCtx (bicom lemma_62)) @
    bitr exists_appCtx @
    bitr (cong_of_equiv_exists @ lemma_60_b) @
    cong_of_equiv_exists ancomb);

do {
  (def (appCtx_pointwise_subst subst) '(norm (norm_equiv ,subst @ norm_exists @ norm_and_l ,subst) appCtx_pointwise))
};

-- Equality reasoning

theorem in_refl: $ x in eVar x $ =
  '(framing_def (iand id id) definedness);

theorem eq_trans: $(phi1 == phi2) -> (phi2 == phi3) -> (phi1 == phi3)$ =
  '(exp @ rsyl (anr propag_and_floor) @ framing_floor @ curry bitr);

theorem subset_trans: $(phi1 C_ phi2) -> (phi2 C_ phi3) -> (phi1 C_ phi3)$ =
  '(exp @ rsyl (anr propag_and_floor) @ framing_floor @ curry imim1);

theorem eq_to_intro:
  $ (phi1 == phi2) -> (phi1 -> phi2) $ =
  '(syl anl corollary_57_floor);
theorem eq_to_intro_rev:
  $ (phi1 == phi2) -> (phi2 -> phi1) $ =
  '(syl anr corollary_57_floor);

theorem eq_to_taut (h: $ phi $): $ (phi1 == phi2) -> phi $ = '(a1i h);
theorem eq_to_id: $ (phi1 == phi2) -> (phi -> phi) $ = '(eq_to_taut id);
theorem eq_to_id_bi: $ (phi1 == phi2) -> (phi <-> phi) $ = '(eq_to_taut biid);

theorem eq_to_appCtx {box: SVar} (ctx: Pattern box) (phi1 phi2 psi1 psi2: Pattern)
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> (app[ psi1 / box ] ctx) -> app[ psi2 / box ] ctx $ =
  '(lemma_14 h);

theorem eq_to_framing {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ (phi1 == phi2) -> ((app[ phi1 / box ] ctx) -> app[ phi2 / box ] ctx) $ =
  '(eq_to_appCtx eq_to_intro);

theorem eq_to_def
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> (|^ psi1 ^| -> |^ psi2 ^|) $ =
  '(norm (norm_imp_r @ norm_imp defNorm defNorm) (! eq_to_appCtx box _ _ _ _ _ h));

theorem eq_to_and
  (h1: $ (phi1 == phi2) -> (psi1 -> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 -> rho2) $):
  $ (phi1 == phi2) -> ((psi1 /\ rho1) -> (psi2 /\ rho2)) $ =
  '(animd h1 h2);
theorem eq_to_and_l
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((psi1 /\ rho) -> (psi2 /\ rho)) $ =
  '(anim1d h);
theorem eq_to_and_r
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((rho /\ psi1) -> (rho /\ psi2)) $ =
  '(anim2d h);

theorem eq_to_imp
  (h1: $ (phi1 == phi2) -> (psi2 -> psi1) $)
  (h2: $ (phi1 == phi2) -> (rho1 -> rho2) $):
  $ (phi1 == phi2) -> ((psi1 -> rho1) -> (psi2 -> rho2)) $ =
  '(imimd h1 h2);
theorem eq_to_imp_l
  (h: $ (phi1 == phi2) -> (psi2 -> psi1) $):
  $ (phi1 == phi2) -> ((psi1 -> rho) -> (psi2 -> rho)) $ =
  '(imim1d h);
theorem eq_to_imp_r
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((rho -> psi1) -> (rho -> psi2)) $ =
  '(imim2d h);

theorem eq_to_not
  (h: $ (phi1 == phi2) -> (psi2 -> psi1) $):
  $ (phi1 == phi2) -> ((~ psi1) -> (~ psi2)) $ =
  '(eq_to_imp_l h);

theorem eq_to_or
  (h1: $ (phi1 == phi2) -> (psi1 -> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 -> rho2) $):
  $ (phi1 == phi2) -> ((psi1 \/ rho1) -> (psi2 \/ rho2)) $ =
  '(orimd h1 h2);
theorem eq_to_or_l
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((psi1 \/ rho) -> (psi2 \/ rho)) $ =
  '(orim1d h);
theorem eq_to_or_r
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((rho \/ psi1) -> (rho \/ psi2)) $ =
  '(orim2d h);

theorem eq_to_app_l
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((app psi1 rho) -> (app psi2 rho)) $ =
  '(norm
    (norm_imp_r @ norm_imp (norm_trans appCtxL_disjoint @ norm_app appCtxVar norm_refl) (norm_trans appCtxL_disjoint @ norm_app appCtxVar norm_refl))
    (! eq_to_appCtx box _ _ _ _ _ h));
theorem eq_to_app_r
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((app rho psi1) -> (app rho psi2)) $ =
  '(norm
    (norm_imp_r @ norm_imp (norm_trans appCtxR_disjoint @ norm_app norm_refl appCtxVar) (norm_trans appCtxR_disjoint @ norm_app norm_refl appCtxVar))
    (! eq_to_appCtx box _ _ _ _ _ h));
theorem eq_to_app
  (h1: $ (phi1 == phi2) -> (psi1 -> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 -> rho2) $):
  $ (phi1 == phi2) -> ((app psi1 rho1) -> (app psi2 rho2)) $ =
  '(syld (eq_to_app_l h1) (eq_to_app_r h2));

theorem eq_to_exists {x: EVar} (phi1 phi2: Pattern) (psi1 psi2: Pattern x)
  (h: $ (phi1 == phi2) -> (psi1 -> psi2) $):
  $ (phi1 == phi2) -> ((exists x psi1) -> (exists x psi2)) $ =
  '(exp @ rsyl and_exists_disjoint_reverse @ exists_framing @ curry h);

do {
  (def (bi_lift pf to_equiv) '(iand (,pf @ syl anl ,to_equiv) (,pf @ syl anr ,to_equiv)))
  (def (bi_lift2 pf to_equiv1 to_equiv2) '(iand (,pf (syl anl ,to_equiv1) (syl anl ,to_equiv2)) (,pf (syl anr ,to_equiv1) (syl anr ,to_equiv2))))
  (def (eq_lift pf to_eq) '(rsyl (bi2 floor_idem) @ framing_floor @ ,pf (syl corollary_57_floor ,to_eq)))
  (def (eq_lift2 pf to_eq1 to_eq2) '(rsyl (bi2 floor_idem) @ framing_floor @ ,pf (syl corollary_57_floor ,to_eq1) (syl corollary_57_floor ,to_eq2)))
};

theorem eq_to_intro_bi:
  $ (phi1 == phi2) -> (phi1 <-> phi2) $ =
  'corollary_57_floor;
theorem eq_to_intro_rev_bi:
  $ (phi1 == phi2) -> (phi2 <-> phi1) $ =
  '(syl bicom corollary_57_floor);

theorem eq_to_appCtx_bi {box: SVar} (ctx: Pattern box) (phi1 phi2 psi1 psi2: Pattern)
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((app[ psi1 / box ] ctx) <-> app[ psi2 / box ] ctx) $ = (bi_lift 'eq_to_appCtx 'h);

theorem eq_to_framing_bi {box: SVar} (ctx: Pattern box) (phi1 phi2: Pattern):
  $ (phi1 == phi2) -> ((app[ phi1 / box ] ctx) <-> app[ phi2 / box ] ctx) $ = '(eq_to_appCtx_bi eq_to_intro_bi);

theorem eq_to_def_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> (|^ psi1 ^| <-> |^ psi2 ^|) $ = (bi_lift 'eq_to_def 'h);

theorem eq_to_and_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((psi1 /\ rho1) <-> (psi2 /\ rho2)) $ = (bi_lift2 'eq_to_and 'h1 'h2);
theorem eq_to_and_l_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((psi1 /\ rho) <-> (psi2 /\ rho)) $ = (bi_lift 'eq_to_and_l 'h);
theorem eq_to_and_r_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((rho /\ psi1) <-> (rho /\ psi2)) $ = (bi_lift 'eq_to_and_r 'h);

theorem eq_to_imp_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((psi1 -> rho1) <-> (psi2 -> rho2)) $ = '(sylc imp_cong_of_equiv_imp h1 h2);
theorem eq_to_imp_l_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((psi1 -> rho) <-> (psi2 -> rho)) $ = '(syl imp_cong_of_equiv_imp_l h);
theorem eq_to_imp_r_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((rho -> psi1) <-> (rho -> psi2)) $ = (bi_lift 'eq_to_imp_r 'h);

theorem eq_to_not_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((~ psi1) <-> (~ psi2)) $ = '(eq_to_imp_l_bi h);

theorem eq_to_floor_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> (|_ psi1 _| <-> |_ psi2 _|) $ = '(eq_to_not_bi @ eq_to_def_bi @ eq_to_not_bi h);

theorem eq_to_or_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((psi1 \/ rho1) <-> (psi2 \/ rho2)) $ = (bi_lift2 'eq_to_or 'h1 'h2);
theorem eq_to_or_l_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((psi1 \/ rho) <-> (psi2 \/ rho)) $ = (bi_lift 'eq_to_or_l 'h);
theorem eq_to_or_r_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((rho \/ psi1) <-> (rho \/ psi2)) $ = (bi_lift 'eq_to_or_r 'h);

theorem eq_to_app_l_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((app psi1 rho) <-> (app psi2 rho)) $ = (bi_lift 'eq_to_app_l 'h);
theorem eq_to_app_r_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((app rho psi1) <-> (app rho psi2)) $ = (bi_lift 'eq_to_app_r 'h);
theorem eq_to_app_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((app psi1 rho1) <-> (app psi2 rho2)) $ = (bi_lift2 'eq_to_app 'h1 'h2);

theorem eq_to_equiv_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((psi1 <-> rho1) <-> (psi2 <-> rho2)) $ = '(sylc bieq h1 h2);
theorem eq_to_equiv_l_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((psi1 <-> rho) <-> (psi2 <-> rho)) $ = '(eq_to_equiv_bi h eq_to_id_bi);
theorem eq_to_equiv_r_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((rho <-> psi1) <-> (rho <-> psi2)) $ = '(eq_to_equiv_bi eq_to_id_bi h);

theorem eq_to_eq_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((psi1 == rho1) <-> (psi2 == rho2)) $ =
  '(eq_to_not_bi @ eq_to_def_bi @ eq_to_not_bi @ eq_to_equiv_bi h1 h2);
theorem eq_to_eq_l_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((psi1 == rho) <-> (psi2 == rho)) $ = '(eq_to_eq_bi h eq_to_id_bi);
theorem eq_to_eq_r_bi
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((rho == psi1) <-> (rho == psi2)) $ = '(eq_to_eq_bi eq_to_id_bi h);

theorem eq_to_exists_bi {x: EVar} (phi1 phi2: Pattern) (psi1 psi2: Pattern x)
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((exists x psi1) <-> (exists x psi2)) $ = (bi_lift 'eq_to_exists 'h);
theorem eq_to_forall_bi {x: EVar} (phi1 phi2: Pattern) (psi1 psi2: Pattern x)
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((forall x psi1) <-> (forall x psi2)) $ =
  '(eq_to_not_bi @ eq_to_exists_bi @ eq_to_not_bi h);

theorem eq_to_mem_bi {x: EVar} (phi1 phi2 psi1 psi2: Pattern x)
  (h: $ (phi1 == phi2) -> (psi1 <-> psi2) $):
  $ (phi1 == phi2) -> ((x in psi1) <-> (x in psi2)) $ =
  '(eq_to_def_bi @ eq_to_and_bi eq_to_id_bi h);

theorem eq_to_gen_mem_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((|^ psi1 /\ rho1 ^|) <-> (|^ psi2 /\ rho2 ^|)) $ =
  '(eq_to_def_bi @ eq_to_and_bi h1 h2);

theorem eq_to_subset_bi
  (h1: $ (phi1 == phi2) -> (psi1 <-> psi2) $)
  (h2: $ (phi1 == phi2) -> (rho1 <-> rho2) $):
  $ (phi1 == phi2) -> ((psi1 C_ rho1) <-> (psi2 C_ rho2)) $ =
  '(eq_to_not_bi @ eq_to_def_bi @ eq_to_not_bi @ eq_to_imp_bi h1 h2);


-- theorem eq_to_eq_app_l
--   (h: $ (phi1 == phi2) -> (psi1 == psi2) $):
--   $ (phi1 == phi2) -> ((app psi1 rho) == (app psi2 rho)) $ =
--   '(syl equiv_to_eq @ ibid (eq_to_app_l @ syl eq_to_intro h) (eq_to_app_l @ syl eq_to_intro @ syl eq_sym h));

theorem not_exists_bot: $ ~ exists x bot $ =
  '(exists_generalization_disjoint taut);

theorem ceil_mem_imp_mem {x: EVar} (phi: Pattern x):
  $ |^ x in phi ^| -> x in phi $ =
  '(syl (con1 membership_not_reverse) @ norm (norm_imp (! defNorm2 box1) @ norm_not (! defNorm box2)) @ dne singleton);

theorem mem_imp_floor_mem {x: EVar} (phi: Pattern x):
  $ (x in phi) -> |_ x in phi _| $ =
  '(con2 @ imim (framing_def membership_not_reverse) membership_not_forward ceil_mem_imp_mem);

theorem lemma_in_in_forward {x y: EVar} (phi: Pattern x y):
  $ (x in (y in phi)) -> y in phi $ =
  '(syl ceil_mem_imp_mem @ framing_def anr);
theorem lemma_in_in_forward_same_var {x: EVar} (phi: Pattern x):
  $ (x in (x in phi)) -> x in phi $ =
  '(syl ceil_mem_imp_mem @ framing_def anr);
theorem lemma_in_in_reverse {x y: EVar} (phi: Pattern x y):
  $ (y in phi) -> x in (y in phi) $ =
  '(rsyl mem_imp_floor_mem @ propag_or_def @
    framing_def lemma_in_in_reverse_helper @ prop_43_or_def @ orr definedness);
theorem lemma_in_in_reverse_same_var {x: EVar} (phi: Pattern x):
  $ (x in phi) -> x in (x in phi) $ =
  '(rsyl mem_imp_floor_mem @ propag_or_def @
    framing_def lemma_in_in_reverse_helper @ prop_43_or_def @ orr definedness);

theorem lemma_in_in {x y: EVar} (phi: Pattern x y):
  $ (x in (y in phi)) <-> y in phi $ =
  '(ibii lemma_in_in_forward lemma_in_in_reverse);
theorem lemma_in_in_same_var {x: EVar} (phi: Pattern x):
  $ (x in (x in phi)) <-> x in phi $ =
  '(ibii lemma_in_in_forward_same_var lemma_in_in_reverse_same_var);

theorem membership_appCtx {x y: EVar} {box: SVar} (ctx: Pattern box x) (phi: Pattern x):
  $ (x in app[ phi / box ] ctx) <-> exists y ((y in phi) /\ (x in app[ eVar y / box ] ctx)) $ =
  '(bitr (cong_of_equiv_mem @ cong_of_equiv_appCtx @ bicom lemma_62) @
    bitr (cong_of_equiv_mem exists_appCtx) @
    bitr (cong_of_equiv_mem @ cong_of_equiv_exists lemma_60_b) @
    bitr (corollary_57_floor membership_exists) @
    bitr (cong_of_equiv_exists membership_and_bi)
         (cong_of_equiv_exists @ cong_of_equiv_and_l lemma_in_in));
theorem membership_appCtx_forward {x y: EVar} {box: SVar} (ctx: Pattern box x) (phi: Pattern x):
  $ (x in app[ phi / box ] ctx) -> exists y ((y in phi) /\ (x in app[ eVar y / box ] ctx)) $
= '(anl membership_appCtx);
theorem membership_appCtx_reverse {x y: EVar} {box: SVar} (ctx: Pattern box x) (phi: Pattern x):
  $ exists y ((y in phi) /\ (x in app[ eVar y / box ] ctx)) -> (x in app[ phi / box ] ctx) $
= '(anr membership_appCtx);

theorem membership_app {x y: EVar} (phi psi: Pattern x):
  $ (x in app phi psi) <-> exists y ((y in psi) /\ (x in app phi (eVar y))) $ =
  (named '(norm (norm_equiv (norm_mem appCtxRVar) @ norm_exists @ norm_and_r @ norm_mem appCtxRVar) membership_appCtx));
theorem membership_app2 {x y z: EVar} (phi psi: Pattern x):
  $ (x in app (app phi psi) rho) <-> exists y ((y in psi) /\ exists z ((z in rho) /\ (x in app (app phi (eVar y)) (eVar z)))) $ =
  (named '(bitr (norm (norm_equiv (norm_mem appCtxLRVar) @ norm_exists @ norm_and_r @ norm_mem appCtxLRVar) membership_appCtx) @
    cong_of_equiv_exists @ cong_of_equiv_and_r membership_app));

do {
  (def (membership_appCtx_subst subst) '(norm (norm_equiv (norm_mem ,subst) @ norm_exists @ norm_and_r (norm_mem ,subst)) membership_appCtx))
};

theorem membership_expand {x y: EVar} (phi: Pattern x):
  $ (x in phi) <-> exists y ((y in phi) /\ (eVar x == eVar y)) $ =
  (named '(bitr ,(membership_appCtx_subst 'appCtxVar) @ cong_of_equiv_exists @ cong_of_equiv_and_r membership_var_bi));

--- lemma 59
-- theorem func_subst_explicit {x: EVar} {y: EVar} (phi1: Pattern x y) (phi2: Pattern x):
--   $ (forall x phi1) /\ (exists y phi2 == eVar y) -> e[ phi2 / x ] phi1 $ =
--   '();

theorem membership_forall_bi {x y: EVar} (phi: Pattern x y):
  $ (x in (forall y phi)) <-> forall y (x in phi) $
  = '(bitr membership_not_bi @ cong_of_equiv_not @ bitr membership_exists_bi @ cong_of_equiv_exists membership_not_bi);
theorem membership_forall {x y: EVar} (phi: Pattern x y):
  $ (x in (forall y phi)) == forall y (x in phi) $
  = '(equiv_to_eq membership_forall_bi);


theorem floor_imp_mem {x: EVar} (phi: Pattern x): $ |_ phi _| -> x in phi $ =
  '(propag_or_def @ framing_def (imim1i dne) @ framing_def ian definedness);

theorem mem_floor_forward {x: EVar} (phi: Pattern x):
  $ (x in |_ phi _|) -> |_ phi _| $ =
  '(con2 @ syl (rsyl notnot1 @ con3 membership_not_forward) @
    syl (norm (norm_imp_r @ norm_mem defNorm) membership_appCtx_reverse) @
    rsyl (anl lemma_ceil_exists_membership) @ exists_framing @ iand id @ a1i @
    framing_def (iand id (a1i @ norm (norm_sym (! defNorm box)) (! definedness y))) definedness);
theorem mem_floor_reverse {x: EVar} (phi: Pattern x):
  $ |_ phi _| -> (x in |_ phi _|) $ =
  '(syl floor_imp_mem @ anr floor_idem);
theorem mem_floor {x: EVar} (phi: Pattern x):
  $ (x in |_ phi _|) <-> |_ phi _| $ =
  '(ibii mem_floor_forward mem_floor_reverse);
theorem mem_def_forward {x: EVar} (phi: Pattern x):
  $ (x in |^ phi ^|) -> |^ phi ^| $ =
  '(syl (framing_def dne) @ rsyl (con2 @ rsyl membership_not_forward @ con3 @ framing_in @ framing_def notnot1) @ con1 mem_floor_reverse);
theorem mem_def_reverse {x: EVar} (phi: Pattern x):
  $ |^ phi ^| -> (x in |^ phi ^|) $ =
  '(rsyl (rsyl (framing_def notnot1) @ con2 mem_floor_forward) @ rsyl (con3 membership_not_reverse) @ rsyl dne @ framing_in @ framing_def dne);
theorem mem_def {x: EVar} (phi: Pattern x):
  $ (x in |^ phi ^|) <-> |^ phi ^| $ =
  '(ibii mem_def_forward mem_def_reverse);

theorem ceil_floor_floor: $ |^ |_ phi _| ^| <-> |_ phi _| $ =
  '(ibii
    (rsyl (anl lemma_ceil_exists_membership) @ exists_generalization_disjoint (! mem_floor_forward x))
    corollary_57_ceil);
theorem floor_ceil_ceil: $ |_ |^ phi ^| _| <-> |^ phi ^| $ =
  '(ibii
    corollary_57_floor
    (rsyl (framing_def notnot1) (rsyl (con2 @ anl ceil_floor_floor) @ framing_floor @ framing_def dne)));

theorem simple_eq_subst: $ phi /\ (phi == psi) -> psi $ = '(rsyl ancom @ curry eq_to_intro);

theorem alpha_exists {x y: EVar} (phi: Pattern x y)
  (y_fresh: $ _eFresh y phi $):
  $ (exists x phi) <-> exists y (e[ eVar y / x ] phi) $ =
  '(ibii
    (exists_generalization
      (eFresh_exists @ eFresh_eSubst_same_var eFresh_disjoint) @
      syl exists_intro @ norm
        (norm_sym @ norm_imp_r @ norm_trans eSubstitution_in_eSubst @
          norm_trans (norm_evSubst_pt norm_refl eSubstitution_in_same_eVar) @ norm_trans eSubstitution_id @ eSubstitution_fresh y_fresh)
        id)
    (exists_generalization (eFresh_exists y_fresh) exists_intro));

theorem alpha_exists_disjoint {x y: EVar} (phi: Pattern x):
  $ (exists x phi) <-> exists y (e[ eVar y / x ] phi) $ =
  '(alpha_exists eFresh_disjoint);

theorem subset_imp_subset_framing {box: SVar} (ctx phi psi: Pattern box):
  $ (phi C_ psi) -> ((app[ phi / box ] ctx) C_ (app[ psi / box ] ctx)) $ =
  '(rsyl (anr floor_idem) @ framing_floor @ lemma_14 subset_to_imp);
theorem eq_imp_eq_framing {box: SVar} (ctx phi psi: Pattern box):
  $ (phi == psi) -> ((app[ phi / box ] ctx) == (app[ psi / box ] ctx)) $ =
  '(rsyl (iand eq_imp_subset @ rsyl eq_sym eq_imp_subset) @ rsyl (anim subset_imp_subset_framing subset_imp_subset_framing) @ curry subset_to_eq);

do {
  (def (subset_imp_subset_framing_subst subst) '(norm (norm_imp_r @ norm_subset ,subst ,subst) subset_imp_subset_framing))
  (def (eq_imp_eq_framing_subst subst) '(norm (norm_imp_r @ norm_eq ,subst ,subst) eq_imp_eq_framing))
};


do {
  (def (cong_of_equiv_propag x equiv_pf ctx) @ match ctx
    [$eVar ,y$ (if (== x y) equiv_pf 'biid)]
    [$exists ,y ,psi$ (if (== x y) 'biid '(cong_of_equiv_exists ,(cong_of_equiv_propag x equiv_pf psi)))]
    [$imp ,phi1 ,phi2$     '(cong_of_equiv_imp    ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    [$app ,phi1 ,phi2$     '(cong_of_equiv_app    ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    -- [$mu ,Y ,psi$        '(cong_of_equiv_mu      ,(cong_of_equiv_propag x equiv_pf psi))]
    [$not ,psi$            '(cong_of_equiv_not    ,(cong_of_equiv_propag x equiv_pf psi))]
    [$or ,phi1 ,phi2$      '(cong_of_equiv_or     ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    [$and ,phi1 ,phi2$     '(cong_of_equiv_and    ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    [$_ceil ,psi$          '(cong_of_equiv_def    ,(cong_of_equiv_propag x equiv_pf psi))]
    [$_floor ,psi$         '(cong_of_equiv_floor  ,(cong_of_equiv_propag x equiv_pf psi))]
    [$_subset ,phi1 ,phi2$ '(cong_of_equiv_subset ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    [$equiv ,phi1 ,phi2$   '(cong_of_equiv_equiv  ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    [$_eq ,phi1 ,phi2$     '(cong_of_equiv_eq     ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    -- forall and _floor not yet implemented

    [$nnimp ,phi1 ,phi2$   '(cong_of_equiv_nnimp  ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag X equiv_pf phi2))]
    [$concat ,phi1 ,phi2$  '(cong_of_equiv_concat ,(cong_of_equiv_propag x equiv_pf phi1) ,(cong_of_equiv_propag x equiv_pf phi2))]
    -- Kleene star not supported
    -- [$kleene ,Y ,psi$     '(cong_of_equiv_kleene ,(cong_of_equiv_propag x equiv_pf psi))]
    [_ 'biid]
  )

  (def (func_subst_explicit_helper x ctx) @ match ctx
    [$eVar ,y$ (if (== x y) 'eq_to_intro_bi 'eq_to_id_bi)]
    [$exists ,y ,psi$ (if (== x y) 'eq_to_id_bi '(eq_to_exists_bi ,(func_subst_explicit_helper x psi)))]
    [$forall ,y ,psi$ (if (== x y) 'eq_to_id_bi '(eq_to_forall_bi ,(func_subst_explicit_helper x psi)))]
    [$_in ,y ,psi$ (if (== x y) '(eq_to_gen_mem_bi eq_to_intro_bi ,(func_subst_explicit_helper x psi)) '(eq_to_mem_bi ,(func_subst_explicit_helper x psi)))]
    [$imp ,phi1 ,phi2$     '(eq_to_imp_bi    ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]
    [$app ,phi1 ,phi2$     '(eq_to_app_bi    ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]
    [$not ,psi$            '(eq_to_not_bi    ,(func_subst_explicit_helper x psi))]
    [$or ,phi1 ,phi2$      '(eq_to_or_bi     ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]
    [$and ,phi1 ,phi2$     '(eq_to_and_bi    ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]
    [$_ceil ,psi$          '(eq_to_def_bi    ,(func_subst_explicit_helper x psi))]
    [$_floor ,psi$         '(eq_to_floor_bi  ,(func_subst_explicit_helper x psi))]
    [$_subset ,phi1 ,phi2$ '(eq_to_subset_bi ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]
    [$equiv ,phi1 ,phi2$   '(eq_to_equiv_bi  ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]
    [$_eq ,phi1 ,phi2$     '(eq_to_eq_bi     ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]

    [$nnimp ,phi1 ,phi2$   '(eq_to_nnimp_bi  ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper X phi2))]
    [$concat ,phi1 ,phi2$  '(eq_to_concat_bi ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]
    [$derivative ,phi1 ,phi2$  '(eq_to_der_bi ,(func_subst_explicit_helper x phi1) ,(func_subst_explicit_helper x phi2))]

    [_ 'eq_to_id_bi]
  )

  (def (func_subst_imp_to_var x ctx) '(com12 @ syl anr ,(func_subst_explicit_helper x ctx)))

  (def (func_subst_explicit x y phi1 forall_x_phi1 func_phi2) '(
    exists_generalization_disjoint (mp (com12 @ syl anl ,(func_subst_explicit_helper x phi1)) (norm ,(propag_e_subst x phi1) (! var_subst ,x ,y ,phi1 ,forall_x_phi1))) ,func_phi2
  ))

  (def (func_subst x phi1 phi1_pf func_phi2) '(
    exists_generalization_disjoint (mp (com12 @ syl anl ,(func_subst_explicit_helper x phi1)) ,phi1_pf) ,func_phi2
  ))
  (def (func_subst_thm func_phi2 x phi1) '(
    exists_generalization_disjoint (mp (com12 @ syl anl ,(func_subst_explicit_helper x (nth 4 @ get-decl phi1))) ,phi1) ,func_phi2
  ))
  (def (func_subst_thm_rev func_phi2 x phi1) '(
    bicom @ exists_generalization_disjoint (mp (com12 @ syl anl ,(func_subst_explicit_helper x (nth 4 @ get-decl phi1))) ,phi1) ,func_phi2
  ))

  (def (membership_var_func_subst func_x func_y) (func_subst 'x $(x in psi) <-> (eVar x == psi)$ (func_subst_thm func_y 'y 'membership_var_bi) func_x))

  -- (exists x (x == phi)) -> ((exists x ((x == phi) /\ ctx[x])) <-> ctx[phi])
  (def (func_to_and_ctx_bi x ctx) '(ibid
    (a1i @ exists_generalization_disjoint @ curry @ syl anl ,(func_subst_explicit_helper x ctx))
    (exp @ rsyl and_exists_disjoint_r_reverse @ exists_framing @ iand anl @ curry @ syl anr ,(func_subst_explicit_helper x ctx))))

  (def (func_subst_fresh fre x phi1 phi1_pf func_phi2) '(
    exists_generalization ,fre (mp (com12 @ syl anl ,(func_subst_explicit_helper x phi1)) ,phi1_pf) ,func_phi2
  ))

  (def (propag_mem x ctx) @ match ctx
    -- special case for top and bottom?
    [$eVar ,y$ (if (== x y) '(taut_equiv_top membership_same_var) 'membership_var_bi)]
    [$exists ,y ,psi$ (if (== x y) 'biid '(bitr membership_exists_bi @ cong_of_equiv_exists ,(propag_mem x psi)))]
    [$forall ,y ,psi$ (if (== x y) 'biid '(bitr membership_forall_bi @ cong_of_equiv_forall ,(propag_mem x psi)))]
    [$_in ,y ,psi$ (if (== x y) 'lemma_in_in_same_var 'lemma_in_in)]
    [$not ,psi$            '(bitr membership_not_bi   @ cong_of_equiv_not   ,(propag_mem x psi))]
    [$imp ,phi1 ,phi2$     '(bitr membership_imp_bi   @ cong_of_equiv_imp   ,(propag_mem x phi1) ,(propag_mem x phi2))]
    [$or ,phi1 ,phi2$      '(bitr membership_or_bi    @ cong_of_equiv_or    ,(propag_mem x phi1) ,(propag_mem x phi2))]
    [$and ,phi1 ,phi2$     '(bitr membership_and_bi   @ cong_of_equiv_and   ,(propag_mem x phi1) ,(propag_mem x phi2))]
    [$equiv ,phi1 ,phi2$   '(bitr membership_equiv_bi @ cong_of_equiv_equiv ,(propag_mem x phi1) ,(propag_mem x phi2))]
    [$app ,phi1 ,phi2$     '(bitr membership_app      @ cong_of_equiv_exists @ cong_of_equiv_and_l ,(propag_mem #undef phi2))]
    [$_ceil ,psi$          'mem_def]
    [$_floor ,psi$         'mem_floor]
    [$_subset ,phi1 ,phi2$ 'mem_floor]
    [$_eq ,phi1 ,phi2$     'mem_floor]

    -- [$nnimp ,phi1 ,phi2$   '(membership_nnimp  ,(propag_mem x phi1) ,(propag_mem X phi2))]
    [$a$ (func_subst 'y $(x in (eVar y)) <-> (eVar x == eVar y)$ 'membership_var_bi 'functional_a)]
    [$b$ (func_subst 'y $(x in (eVar y)) <-> (eVar x == eVar y)$ 'membership_var_bi 'functional_b)]
    [$epsilon$ (func_subst 'y $(x in (eVar y)) <-> (eVar x == eVar y)$ 'membership_var_bi 'functional_epsilon)]
    [$concat ,phi1 ,phi2$  '(bitr membership_app2 @ cong_of_equiv_exists @ cong_of_equiv_and ,(propag_mem #undef phi1) @ cong_of_equiv_exists @ cong_of_equiv_and_l ,(propag_mem #undef phi2))]
  
    [_ 'biid]
  )
};

theorem func_subst_explicit_test_1 {x y: EVar} (phi: Pattern)
  (h1: $ forall x (|^ eVar x ^|) $)
  (h2: $ exists y (eVar y == phi) $):
  $ |^ phi ^| $ =
  (func_subst_explicit 'x 'y $|^ eVar x ^|$ 'h1 'h2);

theorem func_subst_test_1 {x: EVar} (phi: Pattern)
  (h1: $ (~ eVar x) $)
  (h2: $ exists x (eVar x == phi) $):
  $ (~ phi) $ =
  (func_subst 'x $(~ eVar x)$ 'h1 'h2);

theorem propag_mem_test_01 {x: EVar}:
  $ (x in ~ top) <-> (~ (x in top)) $ =
  (propag_mem 'x $~ top$);

theorem propag_mem_test_02 {x y: EVar}:
  $ (x in (~ (eVar x /\ eVar y))) <-> (~ (top /\ (eVar x == eVar y))) $ =
  (propag_mem 'x $~ (eVar x /\ eVar y)$);

theorem propag_mem_test_11 {x y: EVar} (phi: Pattern x):
  $ (x in (~ ((phi /\ (eVar y \/ (exists y (phi /\ y in phi)) \/ |^ phi ^|)) <-> eVar x))) <-> (~ ((x in phi /\ ((eVar x == eVar y) \/ (exists y ((x in phi) /\ y in phi)) \/ |^ phi ^|)) <-> top)) $ =
  (propag_mem 'x $~ ((phi /\ (eVar y \/ (exists y (phi /\ y in phi)) \/ |^ phi ^|)) <-> eVar x)$);

theorem propag_mem_test_12 {x y z: EVar}:
  $ (x in ~(app (sym defSym) (bot -> eVar y))) <-> ~(exists z (((z in bot) -> (eVar z == eVar y)) /\ (x in app (sym defSym) (eVar z)))) $ =
  (propag_mem 'x $~(app (sym defSym) (bot -> eVar y))$);
